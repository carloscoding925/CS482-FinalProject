# -*- coding: utf-8 -*-
"""model2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GpvAVK5OqrokBXDoNkYoiVM0LiMnTWUj
"""

import joblib
import numpy as np
import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_recall_fscore_support
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, MinMaxScaler

class MyLogisticRegression:
    def __init__(self, perform_test=True):
        self.training_set = None
        self.test_set = None
        self.model_logistic = None
        self.X_train = None
        self.y_train = None
        self.X_test = None
        self.y_test = None
        self.label_encoder = None  # Declare label_encoder as an instance attribute
        self.perform_test = perform_test
        self.dataset_path = "data/weather_classification_data.csv"
        self.read_csv()

    def read_csv(self):
        """
        Reads the dataset and preprocesses it.
        """
        data = pd.read_csv(self.dataset_path)
        X = data.drop('Weather Type', axis=1)
        y = data['Weather Type']

        # Temperature, Humidity, Wind Speed, Precip, Cloud Cover, Atmoshpheric Pressure, UV Index, Season, Visibility, Location
        # Float        Float      Float       Float   String       Float                  Float     String  Float      String

        # Preprocess data
        le_cloudCover = LabelEncoder()
        le_season = LabelEncoder()
        le_location = LabelEncoder()

        X['Cloud Cover'] = le_cloudCover.fit_transform(X['Cloud Cover'])
        X['Season'] = le_season.fit_transform(X['Season'])
        X['Location'] = le_location.fit_transform(X['Location'])

        self.label_encoder = LabelEncoder()  # Assign the label encoder instance to the class attribute
        y_encoded = self.label_encoder.fit_transform(y)
        scaler = MinMaxScaler()
        X_scaled = scaler.fit_transform(X)

        joblib.dump(le_cloudCover, 'le_cloudCover.pkl')
        joblib.dump(le_season, 'le_season.pkl')
        joblib.dump(le_location, 'le_location.pkl')
        joblib.dump(self.label_encoder, 'label_encoder.pkl')
        joblib.dump(scaler, 'scaler.pkl')

        # Split into training and test sets
        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X_scaled, y_encoded, test_size=0.5, random_state=42)

    def model_fit_logistic(self, C=1.0, penalty='l2', solver='lbfgs', max_iter=100):
        """
        Initialize self.model_logistic and call the fit function.
        """
        self.model_logistic = LogisticRegression(C=C, penalty=penalty, solver=solver, max_iter=max_iter)
        self.model_logistic.fit(self.X_train, self.y_train)

    def model_predict_logistic(self):
        """
        Calculate and return the accuracy, precision, recall, f1, support of the model.
        """
        self.model_fit_logistic()
        predictions = self.model_logistic.predict(self.X_test)

        # Calculate metrics
        accuracy = accuracy_score(self.y_test, predictions)
        precision, recall, f1, support = precision_recall_fscore_support(self.y_test, predictions, average=None)

        # Get label mappings
        label_mapping = {i: label for i, label in enumerate(self.label_encoder.classes_)}

        # Attach class labels to precision, recall, etc.
        metrics = {
            "Accuracy": accuracy,
            "Metrics": []
        }
        for i, class_label in label_mapping.items():
            metrics["Metrics"].append({
                "Class": class_label,
                "Precision": precision[i],
                "Recall": recall[i],
                "F1 Score": f1[i],
                "Support": support[i]
            })
        return metrics
    
def predict_from_features(model, features, label_encoder):
        try:
            features_array = np.array(features).reshape(1, -1)
            prediction = model.predict(features_array)
            prediction_class = int(prediction[0])
            prediction_label = label_encoder.inverse_transform([prediction_class])[0]
            return {"Predicted Class": prediction_label}
        except Exception as e:
            return {"Prediction failed": str(e)}

if __name__ == '__main__':
    # Instantiate the MyLogisticRegression class
    logistic_model = MyLogisticRegression()

    # Predict and evaluate
    metrics = logistic_model.model_predict_logistic()
    precision_avg=0
    recall_avg=0
    f1_avg=0
    # Output results and calculate averages
    print(f"Accuracy: {metrics['Accuracy']}")
    for metric in metrics["Metrics"]:
        print(f"Class: {metric['Class']}")
        print(f"  Precision: {metric['Precision']}")
        print(f"  Recall: {metric['Recall']}")
        print(f"  F1 Score: {metric['F1 Score']}")
        print(f"  Support: {metric['Support']}")

        # Sum precision, recall, and F1 scores for averaging
        precision_avg += metric['Precision']
        recall_avg += metric['Recall']
        f1_avg += metric['F1 Score']

    # Calculate macro averages
    num_classes = len(metrics["Metrics"])
    precision_avg = precision_avg / num_classes
    recall_avg = recall_avg / num_classes
    f1_avg = f1_avg / num_classes

    # Print averages
    print("\nAverages:")
    print(f"  Average Precision: {precision_avg}")
    print(f"  Average Recall: {recall_avg}")
    print(f"  Average F1 Score: {f1_avg}")